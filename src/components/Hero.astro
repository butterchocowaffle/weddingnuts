---
import SearchForm from "./SearchForm";
import landingContent from "../data/landing-content.json";

const { hero } = landingContent;
---

<header
    class="relative min-h-screen flex items-center justify-center overflow-hidden snap-start"
    id="hero-section"
>
    <!-- Static Fallback Image / Base Layer (Always visible underneath) -->
    <div class="absolute inset-0 z-0 select-none">
        <img
            src="https://images.unsplash.com/photo-1519741497674-611481863552?ixlib=rb-4.0.3&auto=format&fit=crop&w=2070&q=80"
            alt="Indian Wedding Celebration"
            class="w-full h-full object-cover opacity-80"
        />
        <div
            class="hero-overlay absolute inset-0 bg-black/40 bg-gradient-to-b from-black/60 via-transparent to-black/60"
        >
        </div>
    </div>

    <!-- Video Backgrounds Container -->
    <div class="absolute inset-0 z-0">
        {
            hero.videos.map(
                (video, index) =>
                    (video.type === "url" || !video.type) && (
                        <div
                            class="hero-video-container absolute inset-0 transition-opacity duration-1000 ease-in-out opacity-0"
                            data-index={index}
                        >
                            <video
                                autoplay
                                muted
                                playsinline
                                preload="auto"
                                class="w-full h-full object-cover"
                            >
                                <source src={video.data} type="video/mp4" />
                            </video>
                            <div class="hero-overlay absolute inset-0 bg-black/40 bg-gradient-to-b from-black/60 via-transparent to-black/60" />
                        </div>
                    ),
            )
        }
    </div>

    <div class="relative z-10 text-center px-4 max-w-4xl w-full">
        <!-- Programmable Text Container -->
        <div
            id="hero-text-container"
            class="min-h-[350px] flex flex-col justify-center items-center mt-32 mb-12"
        >
            {
                hero.texts.map((text, index) => (
                    <div
                        class={`hero-text-group absolute w-full ${index === 0 ? "opacity-100 anim-fade-up" : "opacity-0 pointer-events-none"}`}
                        data-index={index}
                        data-duration={text.duration}
                    >
                        <h1 class="text-4xl md:text-6xl font-serif font-bold text-white mb-4 text-shadow leading-tight">
                            {text.bigText}
                            <br />
                            <span class="text-marigold-400">
                                {text.bigTextYellow}
                            </span>
                        </h1>
                        <p class="text-lg md:text-xl text-gray-100 mb-8 max-w-2xl mx-auto font-light">
                            {text.smallText}
                        </p>
                    </div>
                ))
            }
        </div>

        <!-- Search Form Mount Point -->
        <div class="relative z-30 animate-fade-in-up delay-200">
            <SearchForm client:load />
        </div>

        <div
            class="mt-6 flex justify-center gap-6 text-white/90 text-sm animate-fade-in-up delay-300 relative z-20"
        >
            <span class="flex items-center gap-2">
                <i class="fas fa-check-circle text-marigold-400"></i> Verified Vendors
            </span>
            <span class="flex items-center gap-2">
                <i class="fas fa-check-circle text-marigold-400"></i> Best Price Guarantee
            </span>
        </div>
    </div>
</header>

<script>
    const videoContainers = document.querySelectorAll(".hero-video-container");
    const videos = Array.from(videoContainers).map((container) =>
        container.querySelector("video"),
    );
    let currentVideoIndex = -1; // Start with fallback visible
    let isSwitching = false;

    // Helper to safely play video
    const playVideoToCheck = async (videoEl) => {
        try {
            // Ensure video is ready enough
            if (videoEl.readyState < 2) {
                await new Promise((resolve) => {
                    videoEl.oncanplay = resolve;
                    // Timeout fallback
                    setTimeout(resolve, 3000);
                });
            }

            await videoEl.play();
            return true;
        } catch (e) {
            // Ignore AbortError which happens if we pause quickly or navigate away
            if (e.name === "AbortError") {
                // Even if aborted, check if it's actually playing (sometimes AbortError is false positive during rapid state changes)
                return !videoEl.paused;
            }
            console.warn("Video failed to play:", videoEl.src, e);
            return false;
        }
    };

    const switchVideo = async () => {
        if (isSwitching) return;
        isSwitching = true;

        let nextIndex = (currentVideoIndex + 1) % videoContainers.length;
        let attempts = 0;
        let foundPlayable = false;

        // Try to find the next playable video
        while (attempts < videos.length && !foundPlayable) {
            const nextContainer = videoContainers[nextIndex];
            const nextVideo = videos[nextIndex];

            // Reset time to 0 to ensure loop starts from beginning
            nextVideo.currentTime = 0;

            const isPlaying = await playVideoToCheck(nextVideo);

            if (isPlaying) {
                // If we found a playable video, switch to it
                if (currentVideoIndex >= 0) {
                    // Hide current video
                    const currentContainer = videoContainers[currentVideoIndex];
                    currentContainer.classList.remove("opacity-100");
                    currentContainer.classList.add("opacity-0");

                    // Pause old video after transition to save resources
                    const oldVideo = videos[currentVideoIndex];
                    setTimeout(() => {
                        oldVideo.pause();
                    }, 1000);
                }

                // Show new video
                nextContainer.classList.remove("opacity-0");
                nextContainer.classList.add("opacity-100");

                currentVideoIndex = nextIndex;
                foundPlayable = true;
            } else {
                console.warn(
                    `Skipping video ${nextIndex} due to playback failure.`,
                );
                // If failed, try next one immediately
                nextIndex = (nextIndex + 1) % videoContainers.length;
                attempts++;
            }
        }

        isSwitching = false;

        // If no videos play, we just stay on fallback (currentVideoIndex remains -1 or whatever last worked)
    };

    // Initialize Video Loop
    if (videos.length > 0) {
        // Setup all videos to trigger switch on end
        videos.forEach((video, idx) => {
            video.removeAttribute("loop");

            // Use timeupdate to detect end more reliably than 'ended' if duration is weird
            // But 'ended' is standard. Let's stick to ended but debounce it.
            video.onended = () => {
                // Only switch if this is the ACTIVE video
                if (idx === currentVideoIndex && !isSwitching) {
                    switchVideo();
                }
            };

            video.onerror = (e) => {
                console.error("Video error during playback:", e);
                // If the error happens on the current video, force switch
                if (idx === currentVideoIndex && !isSwitching) {
                    switchVideo();
                }
            };
        });

        // Start the loop
        setTimeout(switchVideo, 100); // Small delay to let initial hydration settle
    }

    // --- Text Animation Logic ---
    // --- Text Animation Logic ---
    const textGroups = document.querySelectorAll(".hero-text-group");
    let currentTextIndex = 0;
    const FADE_DURATION = 800; // Match CSS
    const animationClasses = [
        "anim-fade-up",
        "anim-zoom-in",
        "anim-slide-right",
        "anim-blur-in",
        "anim-scale-reveal",
    ];

    let lastAnimIndex = -1;

    const switchText = () => {
        // 1. Fade OUT current
        const currentGroup = textGroups[currentTextIndex];

        // Remove any existing animation classes to reset
        currentGroup.classList.remove(...animationClasses);

        currentGroup.classList.remove("opacity-100", "translate-y-0");
        currentGroup.classList.add(
            "opacity-0",
            "pointer-events-none", // We don't need translate-y-8 because we have custom animations now
        );

        // 2. Wait for fade out to complete before showing next (Gap)
        setTimeout(() => {
            const nextIndex = (currentTextIndex + 1) % textGroups.length;
            const nextGroup = textGroups[nextIndex];

            // Pick a random animation (different from last)
            let animIndex;
            do {
                animIndex = Math.floor(Math.random() * animationClasses.length);
            } while (
                animIndex === lastAnimIndex &&
                animationClasses.length > 1
            );
            lastAnimIndex = animIndex;

            const randomAnim = animationClasses[animIndex];

            // 3. Fade IN next with random animation
            nextGroup.classList.remove("opacity-0", "pointer-events-none");
            // Reset base state
            nextGroup.style.opacity = "";
            nextGroup.style.transform = "";

            // Apply animation
            nextGroup.classList.add(randomAnim);
            nextGroup.classList.add("opacity-100"); // Ensure it stays visible

            currentTextIndex = nextIndex;

            // Schedule next switch based on THIS text's duration
            const durationSec = parseInt(nextGroup.dataset.duration || "7");
            scheduleNextText(durationSec * 1000);
        }, FADE_DURATION); // Wait for exit
    };

    const scheduleNextText = (duration) => {
        setTimeout(switchText, duration);
    };

    if (textGroups.length > 1) {
        // Initial start
        const firstDurationSec = parseInt(
            textGroups[0].dataset.duration || "7",
        );
        scheduleNextText(firstDurationSec * 1000);
    }
</script>

<style>
    .animate-fade-in-up {
        animation: fadeInUp 0.8s ease-out forwards;
        opacity: 0;
        transform: translateY(20px);
    }

    .delay-200 {
        animation-delay: 0.2s;
    }
    .delay-300 {
        animation-delay: 0.3s;
    }

    .text-shadow {
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
    }

    /* Random Text Animations */
    .anim-fade-up {
        animation: fadeInUp 0.8s ease-out forwards;
    }

    .anim-zoom-in {
        animation: zoomIn 0.8s ease-out forwards;
    }

    .anim-slide-right {
        animation: slideInRight 0.8s ease-out forwards;
    }

    .anim-blur-in {
        animation: blurIn 0.8s ease-out forwards;
    }

    .anim-scale-reveal {
        animation: scaleReveal 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275)
            forwards;
    }

    /* Keyframes */
    @keyframes fadeInUp {
        from {
            opacity: 0;
            transform: translateY(20px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    @keyframes zoomIn {
        from {
            opacity: 0;
            transform: scale(0.9);
        }
        to {
            opacity: 1;
            transform: scale(1);
        }
    }

    @keyframes slideInRight {
        from {
            opacity: 0;
            transform: translateX(-30px);
        }
        to {
            opacity: 1;
            transform: translateX(0);
        }
    }

    @keyframes blurIn {
        from {
            opacity: 0;
            filter: blur(10px);
        }
        to {
            opacity: 1;
            filter: blur(0);
        }
    }

    @keyframes scaleReveal {
        from {
            opacity: 0;
            transform: scale(1.1);
        }
        to {
            opacity: 1;
            transform: scale(1);
        }
    }
</style>
